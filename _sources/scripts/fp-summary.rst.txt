:orphan:

Moved to google docs

.. _fp-summary:

################################
Functional Programming - Summary
################################

With Rick Riehle


Alright we've covered most if not all of Python's support for Functional Programming, at least as of the language's state circa the time I wrote up this material.

Use Cases & Problem Domains
===========================

During the last many lessons, you may have likely been thinking how, where and why to embrace Functional Programming techniques. We're often down among the weeds when we're programming, so now is a good time to step back and take a look at the lay of the land. For what sorts of programming domains should you start to think functionally rather than remain object oriented?

 Have any new vistas opened along the path of these last lessons? Where would you like to spend more time?

Your travels have only begun
============================

I originally wrote this summary with a topic "Object Oriented Programming vs Functional Programming," but when I'm working in Python I don't really think of it that way. Python doesn't force me to choose between, so I choose both. When I step back from this specific language however, I do begin to see the differences between the paradigms. To continue the culture metaphor, during day-to-day work, when I'm engrossed in problems I'm trying to solve, software I'm trying to build, I don't dwell on the cultural debates between the two paradigms, because Python allows me to choose from either and indeed to mix and match as I see fit. Yet when I back away from the day to day, or take a trip to a solidly Functional programming language, I am presented with strong cultural influences on how to solve problems. I am reminded why the alternative paradigms exist in the first place. I am reminded that they encourage me to think about and solve problems differently. Indeed in many cases, more effectively. I remember that to get the most from the alternative, that I need to approach them with a degree of discipline that Python does not enforce, and so it's up to me.

So I am going to suggest that your travels as a professional programmer should not stop here. You should not be satisfied to always stay at home, comfortable in your Python city with its Python neighborhoods, and never sample the exquisite cultures of far-away, strongly Functional languages like Clojure or Haskell. Those cultures have much to teach you and they will make you a better Python programmer.

I hope you get out there and sample from all of the amazing ways of thinking those cultures offer.

Enjoy the trip.
